// Code generated by MockGen. DO NOT EDIT.
// Source: ports/command-port/command_port.go
//
// Generated by this command:
//
//	mockgen -source=ports/command-port/command_port.go -destination=mocks/mock_command_port.go -package=mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
	io "io"
	reflect "reflect"

	command_port "github.com/chitacloud/timeout-mcp/ports/command-port"
	gomock "go.uber.org/mock/gomock"
)

// MockCommandPort is a mock of CommandPort interface.
type MockCommandPort struct {
	ctrl     *gomock.Controller
	recorder *MockCommandPortMockRecorder
	isgomock struct{}
}

// MockCommandPortMockRecorder is the mock recorder for MockCommandPort.
type MockCommandPortMockRecorder struct {
	mock *MockCommandPort
}

// NewMockCommandPort creates a new mock instance.
func NewMockCommandPort(ctrl *gomock.Controller) *MockCommandPort {
	mock := &MockCommandPort{ctrl: ctrl}
	mock.recorder = &MockCommandPortMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCommandPort) EXPECT() *MockCommandPortMockRecorder {
	return m.recorder
}

// GetStdin mocks base method.
func (m *MockCommandPort) GetStdin() io.WriteCloser {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetStdin")
	ret0, _ := ret[0].(io.WriteCloser)
	return ret0
}

// GetStdin indicates an expected call of GetStdin.
func (mr *MockCommandPortMockRecorder) GetStdin() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetStdin", reflect.TypeOf((*MockCommandPort)(nil).GetStdin))
}

// GetStdout mocks base method.
func (m *MockCommandPort) GetStdout() io.ReadCloser {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetStdout")
	ret0, _ := ret[0].(io.ReadCloser)
	return ret0
}

// GetStdout indicates an expected call of GetStdout.
func (mr *MockCommandPortMockRecorder) GetStdout() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetStdout", reflect.TypeOf((*MockCommandPort)(nil).GetStdout))
}

// IsRunning mocks base method.
func (m *MockCommandPort) IsRunning() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsRunning")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsRunning indicates an expected call of IsRunning.
func (mr *MockCommandPortMockRecorder) IsRunning() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsRunning", reflect.TypeOf((*MockCommandPort)(nil).IsRunning))
}

// Start mocks base method.
func (m *MockCommandPort) Start() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Start")
	ret0, _ := ret[0].(error)
	return ret0
}

// Start indicates an expected call of Start.
func (mr *MockCommandPortMockRecorder) Start() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Start", reflect.TypeOf((*MockCommandPort)(nil).Start))
}

// Stop mocks base method.
func (m *MockCommandPort) Stop() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Stop")
	ret0, _ := ret[0].(error)
	return ret0
}

// Stop indicates an expected call of Stop.
func (mr *MockCommandPortMockRecorder) Stop() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Stop", reflect.TypeOf((*MockCommandPort)(nil).Stop))
}

// MockCommandPortFactory is a mock of CommandPortFactory interface.
type MockCommandPortFactory struct {
	ctrl     *gomock.Controller
	recorder *MockCommandPortFactoryMockRecorder
	isgomock struct{}
}

// MockCommandPortFactoryMockRecorder is the mock recorder for MockCommandPortFactory.
type MockCommandPortFactoryMockRecorder struct {
	mock *MockCommandPortFactory
}

// NewMockCommandPortFactory creates a new mock instance.
func NewMockCommandPortFactory(ctrl *gomock.Controller) *MockCommandPortFactory {
	mock := &MockCommandPortFactory{ctrl: ctrl}
	mock.recorder = &MockCommandPortFactoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCommandPortFactory) EXPECT() *MockCommandPortFactoryMockRecorder {
	return m.recorder
}

// NewCommandPort mocks base method.
func (m *MockCommandPortFactory) NewCommandPort(command string, args ...string) (command_port.CommandPort, error) {
	m.ctrl.T.Helper()
	varargs := []any{command}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "NewCommandPort", varargs...)
	ret0, _ := ret[0].(command_port.CommandPort)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// NewCommandPort indicates an expected call of NewCommandPort.
func (mr *MockCommandPortFactoryMockRecorder) NewCommandPort(command any, args ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{command}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewCommandPort", reflect.TypeOf((*MockCommandPortFactory)(nil).NewCommandPort), varargs...)
}
